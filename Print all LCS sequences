GFG - Print all LCS sequences
Difficulty - Hard
link - https://www.geeksforgeeks.org/problems/print-all-lcs-sequences3413/1

Solution 1 - Recursive Approach --> Time limit exceed O(3^(n + m))

class Solution {
    public int max = Integer.MIN_VALUE;
    
    public void helper(int n, int m, TreeSet<String> set, StringBuilder sb, int i, int j, String s1, String s2, int cnt){
        if(i == n || j == m){
            max = Math.max(max, cnt);
            set.add(sb.toString());
            return;
        }
        
        if(s1.charAt(i) == s2.charAt(j)){
            sb.append(s1.charAt(i));
            helper(n, m, set, sb, i + 1, j + 1, s1, s2, cnt + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
        helper(n, m, set, sb, i + 1, j, s1, s2, cnt);
        helper(n, m, set, sb, i, j + 1, s1, s2, cnt);
        
    }
    public List<String> allLCS(String s1, String s2) {
        // Code here
        int n = s1.length();
        int m = s2.length();
        TreeSet<String> set = new TreeSet<>();
        helper(n, m, set, new StringBuilder(), 0, 0, s1, s2, 0);
        
        List<String> lcs = new ArrayList<>();
        for(String str : set){
            if(str.length() == max) lcs.add(str);
        }
        return lcs;
    }
}

Solution 2 - DP Approach - time limit exceeded -> O(n * m + exponential in LCS length)

class Solution {
    
    public void helper(int n, int m, int[][] dp, TreeSet<String> set, StringBuilder sb, String s1, String s2){
        if(n == 0 || m == 0){
            set.add(sb.reverse().toString());
            sb.reverse();
            return;
        }
        
        if(s1.charAt(n - 1) == s2.charAt(m - 1)){
            sb.append(s1.charAt(n - 1));
            helper(n - 1, m - 1, dp, set, sb, s1, s2);
            sb.deleteCharAt(sb.length() - 1);
        }else if(dp[n - 1][m] > dp[n][m - 1]){
            helper(n - 1, m, dp, set, sb, s1, s2);
        }else if(dp[n][m - 1] > dp[n - 1][m]){
            helper(n, m - 1, dp, set, sb, s1, s2);
        }else{
            helper(n - 1, m, dp, set, sb, s1, s2);
            helper(n, m - 1, dp, set, sb, s1, s2);
        }
        
    }
    public List<String> allLCS(String s1, String s2) {
        // Code here
        int n = s1.length();
        int m = s2.length();
        int[][] dp = new int[n + 1][m + 1];
        
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(s1.charAt(i - 1) == s2.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        
        int lcs = dp[n][m];
        TreeSet<String> set = new TreeSet<>();
        helper(n, m, dp, set, new StringBuilder(), s1, s2);
        
        List<String> ans = new ArrayList<>();
        for(String str : set){
            ans.add(str);
        }
        return ans;
    }
}

Solution 3 Memozitaion --> O(n×m+number of distinct LCS sequences×average string length)

class Solution {
    
    private Map<String, Set<String>> memo;
    
    public Set<String> helper(int n, int m, int[][] dp, String s1, String s2){
        if(n == 0 || m == 0){
            Set<String> baseSet = new HashSet<>();
            baseSet.add("");
            return baseSet;
        }
        
        String key = n + "#" + m;
        if(memo.containsKey(key)) return memo.get(key);
        
        if(s1.charAt(n - 1) == s2.charAt(m - 1)){
            Set<String> temp = helper(n - 1, m - 1, dp, s1, s2);
            Set<String> res = new HashSet<>();
            for(String str : temp){
                res.add(str + s1.charAt(n - 1)); 
            }
            memo.put(key, res);
            return res;
        }else{
            Set<String> res = new HashSet<>();
            if(dp[n - 1][m] >= dp[n][m - 1]){
                res.addAll(helper(n - 1, m, dp, s1, s2));
            }
            if(dp[n][m - 1] >= dp[n - 1][m]){
                res.addAll(helper(n, m - 1, dp, s1, s2));
            }
            memo.put(key, res);
            return res;
        }
    }
    
    public List<String> allLCS(String s1, String s2) {
        int n = s1.length();
        int m = s2.length();
        int[][] dp = new int[n + 1][m + 1];
        

        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                if(s1.charAt(i - 1) == s2.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
        
        memo = new HashMap<>();
        Set<String> lcsSet = helper(n, m, dp, s1, s2);
        
        List<String> ans = new ArrayList<>(lcsSet);
        Collections.sort(ans);
        return ans;
    }
}
